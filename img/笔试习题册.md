# 笔试习题册（数据结构篇）

## 1. 基础

+ 比最大和最小

  ```java
  private static int getMin(int i, int j, int k) {
           int min = i < j ? (i < k ? i : k) : (j < k ? j : k);
           return min ;
       }
  
       private static int getMax(int i, int j, int k) {
           int max = i > j ? (i > k ? i : k) : (j > k ? j : k);
           return  max ;
       }
  
  ```

  

+ 对角线和反对角线打印

  <img src="笔试习题册.assets/image-20210223231920639.png" alt="image-20210223231920639" style="zoom:67%;" />

  ```java
   
  for (int x = 1; x <= m; x++) {//循环7行
               for (int y = 1; y <= m; y++) {//循环7列
                   if (x == y || x + y == m + 1) {//对角线打印O
                       System.out.print("O");
                   } else {
                       System.out.print("*");//其他位置打印.
                   }
               }
               System.out.println();//换行
           }
  
  ```



+ 四舍五入

  ```java
   public static int round(double d) {
           // round方法中,d+0.5后,转换为int类型,并返回.
           int n = (int) (d  + 0.5);
           return n;
       }
  ```

  

## 2. 数组与字符串

+ 扑克牌--两个数组存基础，一个总数组存扑克

  ```java
  public class Test2 {
  	    public static void main(String[] args) {
  	        // 花色数组
  	        String[] hs  = {"黑桃","红桃","梅花","方片"};
  	        // 点数数组
  	        String[] ds = {"A","2","3","4", "5","6","7","8","9","10","J","Q","K"};
  	        printCard(hs,ds);
  	    }
  	    public static void printCard(String[] hs ,String[] ds){
  	        for (int hs_index = 0; hs_index < hs.length; hs_index++) {
  	            for (int ds_index = 0; ds_index < ds.length; ds_index++) {
  	                // 拼接字符串
  	                System.out.print(  hs[hs_index] + ds[ds_index]+" ");
  	            }
  	            // 输出换行
  	            System.out.println();
  	        }
  	    }
  	}
  ```

  

+ 数组的逆序--两头起

  ```java
  for (int min = 0, max = array.length - 1; min < max; min++, max--) {
              int temp = array[min];
              array[min] = array[max];
              array[max] = temp;
          }
  ```

  

+ 统计字符出现的次数---定义长度26的数组用来统计，转成ASCII码存储,打印再转回来

  ```java
  public class Test4 {
       public static void main(String[] args) {
           //  获取长度100的字符数组
           char[] charArray = {'a','l','f','m','f','o','b','b','s','n'};
           //  统计字符数组中字母出现次数
           printCount(charArray);
       }
       public static void printCount(char[] charArray) {
           int[] count= new int[26];
           // 对应保存字母出现的次数
           for (int i = 0; i < charArray.length; i++) {
               int c  = charArray[i];
               count[c- 97]++;
           }
           // 打印字母和次数
           for (int i = 0, ch = 97; i < count.length; i++, ch++) {
               if (count[i] != 0 ) {
                   System.out.println((char) ch + "--" + count[i]);
               }
           }
       }
   }
  ```

  

+ 数组是否对称--双指针

  ![image-20210223232835630](笔试习题册.assets/image-20210223232835630.png)

  ```java
  public class Test6 {
       public static void main(String[] args) {
           int[] arr = {1,2,3,4,3,2,1};
           System.out.println(Arrays.toString(arr) +" 是否对称:" +sym(arr) );
  
           int[] arr2 = {1,2,3,4,5,2,1};
           System.out.println(Arrays.toString(arr2) +" 是否对称:" +sym(arr2) );
       }
  
       public static boolean sym(int[] arr) {
           /*
           start : 数组头
           end :数组尾 
            */
           for (int start = 0 , end = arr.length -1 ; start <= end; start++, end--) {
               // 如果两端一旦有元素不等,就返回false
               if (arr[start] != arr[end]) {     
                   return false;
               }
           }
           return true;
       }
   }
  ```

  

+ 判断数组是否一致--长度和元素

  ```java
  public class Test7 {
       public static void main(String[] args) {
  
           int[] arr = {1,2,3,4,3,2,1};
           int[] arr2 = {1,2,3,4,3,2,1};
           System.out.println(" 是否一致:" +equals(arr ,arr2) );
  
       }
       //  比较数组的内容
       public static boolean equals(int[] arr1, int[] arr2) {
   	// 长度不同,返回false
           if (arr1.length != arr2.length) {
               return false;
           }
   	
   	//
           for (int i = 0; i < arr1.length; i++) {
               // arr1[i] 和 arr2[i]比较
               /*
                * 所有元素都相同才相同，也就是只要有一个不同，这两个数组就是不同
                */
               if (arr1[i] != arr2[i]) {
                   return false;
               }
           }
           return true;
       }
   }
  ```

  

  

  

## 3. 栈和队列

### 基础使用

在java中要实现栈和队列，需要用到java集合的相关知识，特别是Stack、LinkedList等相关集合类型。

#### 一、栈的实现

栈的实现，有两个方法：一个是用java本身的集合类型Stack类型；另一个是借用LinkedList来间接实现Stack。

##### 1.Stack实现

有关Stack的具体知识可以参考：http://www.cnblogs.com/skywang12345/p/3308852.html  

直接用Stack来实现非常方便，常用的api函数如下：

```
 boolean             isEmpty() // 判断当前栈是否为空
 synchronized E             peek() //获得当前栈顶元素
 synchronized E             pop() //获得当前栈顶元素并删除
              E             push(E object) //将元素加入栈顶
synchronized int            search(Object o)  //查找元素在栈中的位置，由栈低向栈顶方向数
```

##### 2.LinkedList实现

LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。
LinkedList 实现 List 接口，能对它进行队列操作。
LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。
当LinkedList被当做栈来使用时，常用api及对应关系如下：

```
栈方法        等效方法
push(e)      addFirst(e)
pop()        removeFirst()
peek()       peekFirst()
	         isEmpty()  //判断是否为空
```




  #### 二、队列的实现

  java中虽然有Queue接口，单java并没有给出具体的队列实现类，而Java中让LinkedList类实现了Queue接口，所以使用队列的时候，一般采用LinkedList。因为LinkedList是双向链表，可以很方便的实现队列的所有功能。

  Queue使用时要尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。它们的优点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。 如果要使用前端而不移出该元素，使用
  element()或者peek()方法。


  java中定义队列 一般这样定义： Queue<E> queue = new LinkedList<E>();

  当采用LinkedList来实现时，api的使用和对用关系如下：

  ```
  队列方法       等效方法
  offer(e)      offer(e)/offerLast(e)  //进队列，将元素加入队列末尾
  poll()        poll()/pollFirst()  //获取队列头的元素并移除
  peek()        peek()/peekFirst()  //获取队列头的元素
  	          isEmpty() //判断是否为空
  ```



#### 三、题目  

  + 20. Valid Parentheses (Easy)

  ```
  "()[]{}"
  
  Output : true
  ```

  ```java
  public boolean isValid(String s) {
      Stack<Character> stack = new Stack<>();
      for (char c : s.toCharArray()) {
          if (c == '(' || c == '{' || c == '[') {
              stack.push(c);
          } else {
              if (stack.isEmpty()) {
                  return false;
              }
              char cStack = stack.pop();
              boolean b1 = c == ')' && cStack != '(';
              boolean b2 = c == ']' && cStack != '[';
              boolean b3 = c == '}' && cStack != '{';
              if (b1 || b2 || b3) {
                  return false;
              }
          }
      }
      return stack.isEmpty();
  }
  ```

  + 232. Implement Queue using Stacks (Easy)

    ```
    栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。
    ```

    ```java
    class MyQueue {
        private Stack <Integer> in;
        private Stack <Integer> out;
    
        /** Initialize your data structure here. */
        public MyQueue() {
            in =new Stack <Integer>();
            out=new Stack <Integer>();
    
    
        }
        
        /** Push element x to the back of queue. */
        public void push(int x) {
            in.push(x);
    
        }
        
        /** Removes the element from in front of queue and returns that element. */
        public int pop() {
            in_out();
            int x=out.pop();
            out_in();
            return x;
            
    
        }
        
        /** Get the front element. */
        public int peek() {
            in_out();
            int x=out.peek();
            out_in();
            return x;
    
        }
        
        /** Returns whether the queue is empty. */
        public boolean empty() {
            return (in.isEmpty()&&out.isEmpty());
    
        }
        private void in_out(){
            while(!in.isEmpty()){
                int x=in.pop();
                out.push(x);
            }
        }
         private void out_in(){
            while(!out.isEmpty()){
                int x=out.pop();
                in.push(x);
            }
        }
    }
    
    /**
     * Your MyQueue object will be instantiated and called as such:
     * MyQueue obj = new MyQueue();
     * obj.push(x);
     * int param_2 = obj.pop();
     * int param_3 = obj.peek();
     * boolean param_4 = obj.empty();
     */
    ```

+ 225. Implement Stack using Queues (Easy)

       ```
       在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。
       ```

       ```java
       class MyStack {
       
         private Queue<Integer> queue;
       
       
       
         /** Initialize your data structure here. */
       
         public MyStack() {
       
           queue=new LinkedList<Integer>();
       
       
       
         }
       
         
       
         /** Push element x onto stack. */
       
         public void push(int x) {
       
           queue.offer(x);
       
       
       
         }
       
         
       
         /** Removes the element on top of the stack and returns that element. */
       
         public int pop() {
       
       ​    circle_queue();
       
       ​    return queue.poll();
       
       ​    
       
       
       
       
       
         }
       
         
       
         /** Get the top element. */
       
         public int top() {
       
           circle_queue();
       
           int x=queue.peek();
       
           queue.offer(queue.poll());
       
           return x;
       
       
       
         }
       
         
       
         /** Returns whether the stack is empty. */
       
         public boolean empty() {
       
           return queue.isEmpty();
       
       
       
         }
       
         private void circle_queue(){
       
           for(int i=0;i<(queue.size()-1);i++){
       
             queue.offer(queue.poll());
       
           }
       
         }
       
       }
       
       
       
       /**
       
        \* Your MyStack object will be instantiated and called as such:
       
        \* MyStack obj = new MyStack();
       
        \* obj.push(x);
       
        \* int param_2 = obj.pop();
       
        \* int param_3 = obj.top();
       
        \* boolean param_4 = obj.empty();
       
        */
       ```

+ 155. Min Stack (Easy)最小值栈

  **维护一个最小栈，元素与原有的栈相同数量，和原有的栈同时出压栈，每次压入都与栈顶元素比较，最小栈压入其中的较小者。**

  ![image-20210304143539775](笔试习题册.assets/image-20210304143539775.png)

  ```java
  class MinStack {
      private int min;
      private Stack<Integer> stack;
      private Stack<Integer> minstack;
  
      /** initialize your data structure here. */
      public MinStack() {
          stack=new Stack<>();
          minstack=new Stack<>();
          min=Integer.MAX_VALUE;
          
      }
      //进出栈都要维护min变量
      public void push(int x) {
          stack.push(x);
          min=Math.min(min,x);
          minstack.push(min);
          
  
      }
      
      public void pop() {
          stack.pop();
          minstack.pop();
          min=minstack.isEmpty()? Integer.MAX_VALUE:minstack.peek();
  
      }
      
      public int top() {
          return stack.peek();
      }
      
      public int getMin() {
          return minstack.peek();
  
      }
  }
  ```

  

+ 739. 数组中元素与下一个比它大的元素之间的距离

  **在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。**

  ![image-20210304142813044](笔试习题册.assets/image-20210304142813044.png)

```
Input: [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1, 1, 4, 2, 1, 1, 0, 0]
```

```java
class Solution {
       private class node{
            public int index;
            public int num;
            public node(int i,int n){
                index=i;
                num=n;
            } 
            public node(){
                index=0;
                num=0;
            }

        }
    public int[] dailyTemperatures(int[] T) {
     
        Stack <node>stack=new Stack<>();
        int []count =new int[T.length];
        for(int i=0;i<T.length;i++)
        {
            if(stack.isEmpty()||T[i]<=stack.peek().num){
            stack.push(new node(i,T[i]));
            }
            while(!stack.isEmpty()&&T[i]>stack.peek().num){
                count[stack.peek().index]=i-stack.peek().index;
                stack.pop();
            }
            stack.push(new node(i,T[i]));

        }
        while(!stack.isEmpty()){
            count[stack.pop().index]=0;
        }
        return count;
        


    }
}

//题解
public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] dist = new int[n];
    Stack<Integer> indexs = new Stack<>();
    for (int curIndex = 0; curIndex < n; curIndex++) {
        while (!indexs.isEmpty() && temperatures[curIndex] > temperatures[indexs.peek()]) {
            int preIndex = indexs.pop();
            dist[preIndex] = curIndex - preIndex;
        }
        indexs.add(curIndex);
    }
    return dist;
}
```

+ 503. 循环数组中比当前元素大的下一个元素

  **和上面思路相同，但是需要遍历数组两遍（因为是循环数组）**
  

![image-20210304145303410](笔试习题册.assets/image-20210304145303410.png)


  ```
  Input: [1,2,1]
  Output: [2,-1,2]
  Explanation: The first 1's next greater number is 2;
  The number 2 can't find next greater number;
The second 1's next greater number needs to search circularly, which is also 2.
  ```

  问题：遍历两遍会有已经有答案的最后一个数被压入栈，有多个本该-1的值被分隔开如stack[1,2,3,4,1,2,3,4]

```java
//题解
public int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] next = new int[n];
    Arrays.fill(next, -1);
    Stack<Integer> pre = new Stack<>();
    for (int i = 0; i < n * 2; i++) {
        int num = nums[i % n];
        while (!pre.isEmpty() && nums[pre.peek()] < num) {
            next[pre.pop()] = num;
        }
        if (i < n){
            pre.push(i);
        }
    }
    return next;
}
```

## 4. 链表

+ 160. Intersection of Two Linked Lists (Easy)

例如以下示例中 A 和 B 两个链表相交于 c1：

```
A:          a1 → a2
                    ↘
                      c1 → c2 → c3
                    ↗
B:    b1 → b2 → b3
```

但是不会出现以下相交的情况，因为每个节点只有一个 next 指针，也就只能有一个后继节点，而以下示例中节点 c 有两个后继节点。

```
A:          a1 → a2       d1 → d2
                    ↘  ↗
                      c
                    ↗  ↘
B:    b1 → b2 → b3        e1 → e2
```

要求时间复杂度为 O(N)，空间复杂度为 O(1)。如果不存在交点则返回 null。

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode l1 = headA, l2 = headB;
    while (l1 != l2) {
        l1 = (l1 == null) ? headB : l1.next;
        l2 = (l2 == null) ? headA : l2.next;
    }
    return l1;
}
```

如果只是判断是否存在交点，那么就是另一个问题，即 [编程之美 3.6](https://github.com/CyC2018/CS-Notes/blob/master/notes) 的问题。有两种解法：

	+ 把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；
	
	+ 或者直接比较两个链表的最后一个节点是否相同。

  










+ 206.反转链表

  ```
  输入: 1->2->3->4->5->NULL
  输出: 5->4->3->2->1->NULL
  ```
  + 递归
  
    ![image-20210311101023642](笔试习题册.assets/image-20210311101023642.png)
  
    ```java
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode next = head.next;
        ListNode newHead = reverseList(next);
        next.next = head;
        head.next = null;
        return newHead;
    }
    ```

   + 迭代
  
     ![image-20210311101127490](笔试习题册.assets/image-20210311101127490.png)
  
     ```java
     class Solution {
         public ListNode reverseList(ListNode head) {
             ListNode prev = null;
             ListNode curr = head;
             while (curr != null) {
                 ListNode next = curr.next;
                 curr.next = prev;
                 prev = curr;
                 curr = next;
             }
             return prev;
         }
     }
     ```
  
     

+ 21. 归并两个有序链表

      ```java
      public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
          if (l1 == null) return l2;
          if (l2 == null) return l1;
          if (l1.val < l2.val) {
              l1.next = mergeTwoLists(l1.next, l2);
              return l1;
          } else {
              l2.next = mergeTwoLists(l1, l2.next);
              return l2;
          }
      }
      ```

+ 83. 从有序链表中删除重复节点

   + 必须删掉重复的前一个节点，才能保证到链表最后一个节点的时候还能判断重复
     
      ```java
      class Solution {
          public ListNode deleteDuplicates(ListNode head) {
              if(head==null||head.next==null){
                  return head;
              }
              if(head.val==head.next.val){
                  head.next=deleteDuplicates(head.next);
                   head=head.next;
              }else{
                  head.next=deleteDuplicates(head.next);
              }
               return head;
      
          }
      }
      ```

+ 19.删除链表的倒数第n个节点

  + 先遍历一遍统计链表个数再指向要删除的节点的前一个节点去删除（注意头结点没有前一个指针所以特殊）

    ```java
    class Solution {
        public ListNode removeNthFromEnd(ListNode head, int n) {
            int count=0;
            ListNode count_head=head;
            while(count_head!=null){
                count++;
                count_head=count_head.next;
            }
            ListNode pre=head;
            if(count-n!=0){
            for(int i=1;i<count-n;i++){
                pre=pre.next;
            }
            pre.next=pre.next.next;
            }else{
                head=head.next;
            }
            return head;
    
    
        }
    }
    ```
    
    
    
  + 使用栈
  
    ![image-20210311142645423](笔试习题册.assets/image-20210311142645423.png)
    
    ```java
    class Solution {
        public ListNode removeNthFromEnd(ListNode head, int n) {
            ListNode dummy = new ListNode(0, head);
            Deque<ListNode> stack = new LinkedList<ListNode>();
            ListNode cur = dummy;
            while (cur != null) {
                stack.push(cur);
                cur = cur.next;
            }
            for (int i = 0; i < n; ++i) {
                stack.pop();
            }
            ListNode prev = stack.peek();
            prev.next = prev.next.next;
            ListNode ans = dummy.next;
            return ans;
        }
    }
    
    ```
    
    
    
  + 双指针(两个相差n+1的指针，当后面一个指针指向末尾的时候，前面的指针刚好指向删除元素的前一个)
  
    ![image-20210311143033046](笔试习题册.assets/image-20210311143033046.png)
    
    ```java
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head;
        while (n-- > 0) {
            fast = fast.next;
        }
        if (fast == null) return head.next;
        ListNode slow = head;
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return head;
    }
    ```
    
    


+  328. 链表元素按奇偶聚集

       Example:
       Given 1->2->3->4->5->NULL,
       return 1->3->5->2->4->NULL.
   
   
   ```java
public ListNode oddEvenList(ListNode head) {
       if (head == null) {
           return head;
       }
       ListNode odd = head, even = head.next, evenHead = even;
       while (even != null && even.next != null) {
           odd.next = odd.next.next;
           odd = odd.next;
           even.next = even.next.next;
           even = even.next;
       }
       odd.next = evenHead;
       return head;
   }
   
   ```



+ 203.移除链表中等于X的所有元素

  + 递归

    ```java
    //先判断
    class Solution {
        public ListNode removeElements(ListNode head, int val) {
            if(head==null){
                return head;
            }
            if(head.val==val){
                head=head.next;
                head=removeElements(head,val);
                return head;  
            }else{
                head.next=removeElements(head.next,val);
                return head;
    
            }
    
        }
    }
    //后判断
    class Solution {
        public ListNode removeElements(ListNode head, int val) {
            if (head == null) {
                return null;
            }
            head.next = removeElements(head.next, val);
            // head节点要删除就直接跳过head节点，否则就返回原来的
            return head.val == val ? head.next : head;
        }
    
    ```




## 5. 树

递归

# 笔试习题集（基础算法篇）

## 1. 双指针

